(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{203:function(e,t,a){"use strict";a.r(t);var r=a(0),n=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"daily-interview-question（节选）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#daily-interview-question（节选）","aria-hidden":"true"}},[e._v("#")]),e._v(" Daily-Interview-Question（节选）")]),e._v(" "),a("h3",{attrs:{id:"_1-react-vue-项目里为什么要在列表组件中写key-？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-react-vue-项目里为什么要在列表组件中写key-？","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. React/Vue 项目里为什么要在列表组件中写key ？")]),e._v(" "),a("p",[e._v("简要解析：")]),e._v(" "),a("p",[e._v("key的作用是更新组件时判断两个节点是否相同。相同就复用，不同则进行 销毁/创建 操作。\n正是因为带唯一key时每次更新都不能找到可复用的节点，不但要销毁和创建vnode，在DOM里添加移除节点对性能的影响更大。所以在简单无状态组件的时候，不带key的组件能够复用，省去了销毁/创建组件的开销，同时只需要修改DOM文本内容而不是移除/添加节点，这就是如文档所说：")]),e._v(" "),a("blockquote",[a("p",[e._v("刻意依赖默认行为以获取性能上的提升")])]),e._v(" "),a("p",[e._v("在实际应用中，带key虽然可以增加一些开销，但对用户来说几乎无法感知，而且能减少一些就地复用的副作用（没有过渡效果，状态错位等）")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("详细讨论参考"),a("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1)])])]),e._v(" "),a("hr"),e._v(" "),a("h3",{attrs:{id:"_2-1-2-3-map-parseint-what-why"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-3-map-parseint-what-why","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. ['1', '2', '3'].map(parseInt) what & why ?")]),e._v(" "),a("p",[e._v("简要解析：")]),e._v(" "),a("p",[e._v("map函数的第一个参数是个callback")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])\n")])])]),a("p",[e._v("这个callback接受三个参数，第一个表示当前被处理的元素，第二个是该元素的索引。\n而parseInt用来解析字符串为指定"),a("code",[e._v("基数")]),e._v("的整数。"),a("code",[e._v("parseInt(string, radix)")])]),e._v(" "),a("p",[e._v("所以，运行情况如下：")]),e._v(" "),a("ul",[a("li",[a("ol",[a("li",[e._v("parseInt('1', 0) // radix为0且string参数不以‘0x’或‘0’开头，则按照10进制为基数处理，返回 1")])])]),e._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[e._v("parseInt('2', 1) // 基数为1（1进制）表示的数中,最大值还不到2，无法解析，返回 nan")])])]),e._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[e._v("parseInt('3', 2) // 基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN")])])])]),e._v(" "),a("p",[e._v("故返回 [1, NaN, NaN]")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("详细讨论参考"),a("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/4",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1)])])]),e._v(" "),a("hr")])},[],!1,null,null,null);t.default=n.exports}}]);